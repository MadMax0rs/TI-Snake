; Made with the help of https://ez80.readthedocs.io/en/latest/tutorial/intro.html
#include "D:\TI-84PlusCE\Games\MyGames\ASM\Snake\includes\ti84pce.inc"

; Have to be in order where something is defined BEFORE it is used
TILE_WIDTH						equ 16
TILE_HEIGHT						equ 16
LCD_BUFFER						equ $D40000
LCD_BUFFER_END					equ $D5A3FF
LCD_WIDTH						equ 320
LCD_HEIGHT						equ 240
BYTES_PER_PIXEL					equ 2
LCD_AREA						equ LCD_WIDTH*LCD_HEIGHT			; 76800
TILEMAP_WIDTH					equ LCD_WIDTH/TILE_WIDTH			; 20
TILEMAP_HEIGHT					equ LCD_HEIGHT/TILE_HEIGHT			; 15
TILEMAP_AREA					equ TILEMAP_WIDTH*TILEMAP_HEIGHT	; 300




Facing.Up						equ %0001
Facing.Down						equ %0010
Facing.Left						equ %0100
Facing.Right					equ %1000

Type.Head						equ $0
Type.Body						equ $1
Type.Tail						equ $2
;
; Structs
;

; Snake Segment
SnakeSegment_Size				equ 4		; 1+1+1+1=4
; Attributes
SnakeSegment.Facing				equ 0		; 1 byte
SnakeSegment.Pos				equ 1
SnakeSegment.Pos.X				equ 1		; 1 byte
SnakeSegment.Pos.Y				equ 2		; 1 byte
SnakeSegment.Type				equ 3		; 1 byte

BlackTile						equ $000000
Apple							equ $000200
RightToTop						equ $000400
LeftToTop						equ $000600
BottomToRight					equ $000800
BottomToLeft					equ $000A00
BodyVertical					equ $000C00
BodyHorizontal					equ $000E00
HeadUp							equ $001000
HeadDown						equ $001200
HeadLeft						equ $001400
HeadRight						equ $001600
TailUp							equ $001800
TailDown						equ $001A00
TailLeft						equ $001C00
TailRight						equ $001E00



; Tells the assembler to assume ADL mode is on (basically 24-bit mode), which is the default
.assume ADL=1
; Tells the assembler this program will be located at userMem-2, so any memory addresses should be relative to that
; -2 because the program is placed at userMem, but there are 2 bytes that get removed at runtime (or smth like that, idk look at the tutorial)
.org userMem-2
	; EQUivalent to Asm84CEPrgm in TI-BASIC
	.db tExtTok,tAsm84CeCmp
Start:
	;
	; Program code
	;

	; Reset the screen
	call _homeup
	call _ClrScrnFull
	
	call ResetScreen

	call GetAppVar

Main:
	ld a, (ExitPrgm)
	or a
	jr nz, Exit

	call DrawSnake
	
	;call Test1	; Passed

	; Get key press
	call _GetCSC
	or a
	call nz, HandleKeyPress

	jr Main

ErrorAppVarNotFound:
	ld hl, ErrorAppVarNotFoundStr
	jr Error
ErrorAppVarArchived:
	ld hl, ErrorAppVarArchived
	jr Error

Error:
	call _PutS
	call _GetKey
	ld a, 1
	ld (ExitPrgm), a
	ret

Exit:
	; Hand control back over to the OS
	call _JForceCmdNoChar

	; Exits the program (Usually? idk)
	ret


Test1:
	ld de, (AppVarPointer)
	ld hl, Apple
	add hl, de
	ld a, 0
	ld ixl, 1
	call SetTile

	ld de, (AppVarPointer)
	ld hl, BlackTile
	add hl, de
	ld a, 0
	ld ixl, 2
	call SetTile

	ld de, (AppVarPointer)
	ld hl, Apple
	add hl, de
	ld a, 0
	ld ixl, 3
	call SetTile

	ld de, (AppVarPointer)
	ld hl, BodyVertical
	add hl, de
	ld a, 0
	ld ixl, 4
	call SetTile

	ld de, (AppVarPointer)
	ld hl, RightToTop
	add hl, de
	ld a, 0
	ld ixl, 5
	call SetTile

	ld de, (AppVarPointer)
	ld hl, LeftToTop
	add hl, de
	ld a, 0
	ld ixl, 6
	call SetTile

	ld de, (AppVarPointer)
	ld hl, BodyHorizontal
	add hl, de
	ld a, 0
	ld ixl, 7
	call SetTile

	ld de, (AppVarPointer)
	ld hl, BottomToRight
	add hl, de
	ld a, 0
	ld ixl, 8
	call SetTile

	ld de, (AppVarPointer)
	ld hl, BottomToLeft
	add hl, de
	ld a, 0
	ld ixl, 9
	call SetTile

	ld de, (AppVarPointer)
	ld hl, HeadUp
	add hl, de
	ld a, 0
	ld ixl, $0A
	call SetTile

	ld de, (AppVarPointer)
	ld hl, HeadDown
	add hl, de
	ld a, 0
	ld ixl, $0B
	call SetTile

	ld de, (AppVarPointer)
	ld hl, HeadLeft
	add hl, de
	ld a, 0
	ld ixl, $0C
	call SetTile

	ld de, (AppVarPointer)
	ld hl, HeadRight
	add hl, de
	ld a, 0
	ld ixl, $0D
	call SetTile

	ld de, (AppVarPointer)
	ld hl, TailUp
	add hl, de
	ld a, 0
	ld ixl, $0E
	call SetTile

	ld de, (AppVarPointer)
	ld hl, TailDown
	add hl, de
	ld a, 1
	ld ixl, 0
	call SetTile

	ld de, (AppVarPointer)
	ld hl, TailLeft
	add hl, de
	ld a, 1
	ld ixl, 1
	call SetTile

	ld de, (AppVarPointer)
	ld hl, TailRight
	add hl, de
	ld a, 1
	ld ixl, 2
	call SetTile

	call BlitScreen

	ret



;
; Gets AppVar stored in AppVarName
;
GetAppVar:
	ld hl, AppVarName
	call _Mov9ToOP1

	call _ChkFindSym
	jp c, ErrorAppVarNotFound

	; Check if AppVar is in RAM
	call _ChkInRam

	jp nz, ErrorAppVarArchived
;	jr nz, GetAppVar.Unarchive

	; Pointer to AppVar Data Section stored in de
	ld (AppVarPointer), de
	ret

; GetAppVar.Unarchive:
; 	call _Arc_Unarc
; 	; Re-lookup pointers
; 	jr GetAppVar

;
; Params:
; 	- a: keycode
;
HandleKeyPress:

	cp a, skClear
	jr z, HandleKeyPress.Clear
	cp a, skUp
	jr z, HandleKeyPress.Up
	cp a, skDown
	jr z, HandleKeyPress.Down
	cp a, skLeft
	jr z, HandleKeyPress.Left
	cp a, skRight
	jr z, HandleKeyPress.Right
	ret
HandleKeyPress.Up:
HandleKeyPress.Down:
HandleKeyPress.Left:
HandleKeyPress.Right:
	ret
HandleKeyPress.Clear:
	ld a, 1
	ld (ExitPrgm), a
	ret



;
; Draws the snake to the LCD_BUFFER
;
DrawSnake:
	ld iy, 0
	ld ix, Snake
	ld bc, (SnakeLength)
	inc bc
DrawSegment:
	dec bc
	push bc											; Save bc

	ld iy, (ix)
	push ix											; Save ix
	ld a, (iy+SnakeSegment.Type)
	ld b, (iy+SnakeSegment.Facing)



	ld hl, (AppVarPointer)
	ld de, 0

	cp a, Type.Head
	jr z, DrawSegment.Head
	cp a, Type.Body
	jr z, DrawSegment.Body

; Otherwise, Its tail
	;cp a, Type.Tail
	;jr z, DrawSegment.Tail

;DrawSegment.Tail:
	ld de, TailUp-HeadUp
	add hl, de
DrawSegment.Head:
	ld de, HeadUp
	add hl, de

	ld a, b
; Decide the direction
	; Get the size of 1 tile in the AppVar
	ld bc, TILE_WIDTH*TILE_HEIGHT*BYTES_PER_PIXEL

	cp a, Facing.Up
	jr z, DrawSegment.Head_Tail.Up
	cp a, Facing.Down
	jr z, DrawSegment.Head_Tail.Down
	cp a, Facing.Left
	jr z, DrawSegment.Head_Tail.Left

; Otherwse, its right		; If Right, it needs to add 3
	add hl, bc
DrawSegment.Head_Tail.Left:	; If Left, it needs to add 2
	add hl, bc
DrawSegment.Head_Tail.Down:	; If down, it needs to add 1
	add hl, bc
DrawSegment.Head_Tail.Up:	; If up, its already there
	jr DrawSegment.Done

	




DrawSegment.Body:
	pop ix
	push ix											; Get ix and immediately save it again
	; Get previous segment
	push iy
	ld iy, (ix-3)
	ld a, (iy+SnakeSegment.Facing)
	pop iy
	; a = Previous segment direction
	; b = Current segment direction
	cp a, b
	push af											; Save the flags

	; Move the previous segment direction into the high-order 4-bits of a
	sla a
	sla a
	sla a
	sla a
	or b

	ld c, a
	pop af											; Restore the flags
	ld a, c

	; Do this so that a is still shifted and or-ed
	jr z, DrawSegment.Equal

	tst a, Facing.Up|(Facing.Down<<4)
	jr nz, DrawSegment.Body.Up
	tst a, Facing.Down|(Facing.Up<<4)
	jr nz, DrawSegment.Body.Down

DrawSegment.Equal:
	ld de, BodyVertical
	jr DrawSegment.Body.Next

DrawSegment.Body.Up:
	ld de, RightToTop
	jr DrawSegment.Body.Next

DrawSegment.Body.Down:
	ld de, BottomToRight

DrawSegment.Body.Next:
	add hl, de

	tst a, Facing.Left|(Facing.Right<<4)
	jr z, DrawSegment.Done

	ld de, TILE_WIDTH*TILE_HEIGHT*BYTES_PER_PIXEL
	add hl, de
DrawSegment.Done:
	ld a, (iy+SnakeSegment.Pos.X)
	ld ixl, a
	ld a, (iy+SnakeSegment.Pos.Y)
	call SetTile
	
	pop ix											; Restore ix
	; Increment ix to the next pointer for the cycle after this one
	ld bc, 3
	add ix, bc
	pop bc											; Restore bc
	; If bc == 0, return
	ld a, b
	or a
	jp nz, DrawSegment
	ld a, c
	or a
	jp nz, DrawSegment
	ret




;
; Resets the screen to all black
;
ResetScreen:
	ld hl, LCD_BUFFER
	ld bc, LCD_AREA*BYTES_PER_PIXEL
RestScreen.clearLoop:
    ld (hl), 0
    inc hl
    dec bc
	; Check of bc is zero
	ld (Data), bc										; bc is 24-bit so I have to load it into memory, then load each bit seperately and or them all together
	ld a, (Data+2)
	or b
	or c
    jr nz, RestScreen.clearLoop
	call BlitScreen
	ret

;
; Blits the frame buffer to the screen
;
BlitScreen:
	call $4544    ; _BlitLCD BCALL address for OS 5.8.x
	ret

;
; Moves a given tile into the given render buffer
; Destroys: de, bc
; Params:
; - hl: Pointer to Tile
; - ixl: x pos to place the top left of the tile at
; - a: y pos to place the top left of the tile at
;
SetTile:
	ld de, LCD_BUFFER

	push hl												; Save hl
	push ix

	ld bc, LCD_WIDTH*TILE_HEIGHT*BYTES_PER_PIXEL
	push de
	call mul											; yPos * TILE_HEIGHT * LCD_WIDTH
	pop de

	add hl, de											; Add y offset to *RENDER_BUFFER
	ex de, hl
	
	pop ix
	ld a, ixl
	ld bc, TILE_WIDTH*BYTES_PER_PIXEL
	push de
	call mul											; xPos * TILE_WIDTH
	pop de

	add hl, de											; Add x offset to *RENDER_BUFFER
	ex de, hl

	pop hl												; Restore hl

	ld a, TILE_HEIGHT

	ld bc, TILE_WIDTH*BYTES_PER_PIXEL
	push bc
SetTile.loop:
	pop bc
	push bc
	; Copy memory
	ldir												; Copy 1 row of data from tile buffer to RENDER_BUFFER

	; Move down 1 line to the begnning of the Tile
	push hl												; Start de += (LCD_WIDTH_SUB_TILE_WIDTH - 1)
	ld hl, (LCD_WIDTH-TILE_WIDTH)*BYTES_PER_PIXEL		; -1 because the buffers are 0-based
	add hl, de
	ex de, hl
	pop hl												; End de += (LCD_WIDTH_SUB_TILE_WIDTH - 1)

	dec a
	or a
	jr nz, SetTile.loop
	pop bc
	ret


;
; Multiplies usinga variation of the double and half strategy
; Destroys: de, ix
; Params:
;   A = first number
;   BC = second number
; Output:
;   HL = 24-bit result
;
mul:
	ld h, b
	ld l, a
	call _HtimesL

	ld (Data), hl
	ld ix, Data
	
	; de <<= 8
	sla (ix)
	rl (ix+1)
	rl (ix+2)

	sla (ix)
	rl (ix+1)
	rl (ix+2)
	
	sla (ix)
	rl (ix+1)
	rl (ix+2)
	
	sla (ix)
	rl (ix+1)
	rl (ix+2)
	
	sla (ix)
	rl (ix+1)
	rl (ix+2)
	
	sla (ix)
	rl (ix+1)
	rl (ix+2)
	
	sla (ix)
	rl (ix+1)
	rl (ix+2)
	
	sla (ix)
	rl (ix+1)
	rl (ix+2)
	ld de, (ix)
	push de

	ld h, c
	ld l, a
	call _HtimesL

	pop de
	add hl, de
	ret








ExitPrgm:
	.db 0
ErrorAppVarArchivedStr:
	.db "ERROR, AppVar is archived, please move it into RAM", 0
ErrorAppVarNotFoundStr:
	.db "ERROR, AppVar not found", 0
AppVarName:
	; "VARNAME", 0 (0-padded to 8 bytes), 15h
	.db AppVarObj, "SNKSKN", 0, 0, 0, 0
AppVarPointer:
	.fill 3, 0
Data:
	.fill 64, 0
SnakeLength:
	; Little Endian
	.db 20, 0, 0
Snake:
	; db - 1 byte, dw - 2 bytes, dl - 3 bytes
	.dl Segments+(0*SnakeSegment_Size)
	.dl Segments+(1*SnakeSegment_Size)
	.dl Segments+(2*SnakeSegment_Size)
	.dl Segments+(3*SnakeSegment_Size)
	.dl Segments+(4*SnakeSegment_Size)
	.dl Segments+(5*SnakeSegment_Size)
	.dl Segments+(6*SnakeSegment_Size)
	.dl Segments+(7*SnakeSegment_Size)
	.dl Segments+(8*SnakeSegment_Size)
	
	.dl Segments+(9*SnakeSegment_Size)
	.dl Segments+(10*SnakeSegment_Size)
	.dl Segments+(11*SnakeSegment_Size)
	.dl Segments+(12*SnakeSegment_Size)
	.dl Segments+(13*SnakeSegment_Size)
	.dl Segments+(14*SnakeSegment_Size)
	.dl Segments+(15*SnakeSegment_Size)
	.dl Segments+(16*SnakeSegment_Size)
	.dl Segments+(17*SnakeSegment_Size)
	.dl Segments+(18*SnakeSegment_Size)
	.dl Segments+(19*SnakeSegment_Size)
	.dl Segments+(20*SnakeSegment_Size)

	.fill 3*(TILEMAP_AREA - 9), 0							; *SnakeSegment[LCD_AREA]
Segments:
	; Facing, Pos.X, Pos.Y, Type
	.db Facing.Right, 0, TILEMAP_HEIGHT-1, Type.Tail
	.db Facing.Right, 1, TILEMAP_HEIGHT-1, Type.Body
	.db Facing.Right, 2, TILEMAP_HEIGHT-1, Type.Body
	.db Facing.Right, 3, TILEMAP_HEIGHT-1, Type.Body
	.db Facing.Right, 4, TILEMAP_HEIGHT-1, Type.Body
	.db Facing.Right, 5, TILEMAP_HEIGHT-1, Type.Body
	.db Facing.Right, 6, TILEMAP_HEIGHT-1, Type.Body
	.db Facing.Right, 7, TILEMAP_HEIGHT-1, Type.Body

	.db Facing.Up, 8, TILEMAP_HEIGHT-1, Type.Body
	.db Facing.Up, 8, TILEMAP_HEIGHT-2, Type.Body
	.db Facing.Up, 8, TILEMAP_HEIGHT-3, Type.Body
	.db Facing.Left, 8, TILEMAP_HEIGHT-4, Type.Body
	
	.db Facing.Left, 7, TILEMAP_HEIGHT-4, Type.Body
	.db Facing.Left, 6, TILEMAP_HEIGHT-4, Type.Body
	.db Facing.Down, 5, TILEMAP_HEIGHT-4, Type.Body

	.db Facing.Down, 5, TILEMAP_HEIGHT-3, Type.Body
	.db Facing.Right, 5, TILEMAP_HEIGHT-2, Type.Body

	.db Facing.Up, 6, TILEMAP_HEIGHT-2, Type.Body
	.db Facing.Right, 6, TILEMAP_HEIGHT-3, Type.Body
	.db Facing.Down, 7, TILEMAP_HEIGHT-3, Type.Body


	.db Facing.Down, 7, TILEMAP_HEIGHT-2, Type.Head
	.fill SnakeSegment_Size*(TILEMAP_AREA - 12), 0			; SnakeSegment[LCD_AREA]

