; Made with the help of https://ez80.readthedocs.io/en/latest/tutorial/intro.html
#include "D:/TI-84PlusCE/Games/MyGames/ASM/includes/ti84pce.inc"

; Have to be in order where something is defined BEFORE it is used
TILE_WIDTH						equ 16
TILE_HEIGHT						equ 16
LCD_BUFFER						equ $D40000
LCD_BUFFER_END					equ $D5A3FF
LCD_WIDTH						equ 320
LCD_HEIGHT						equ 240
BYTES_PER_PIXEL					equ 2
LCD_AREA						equ LCD_WIDTH*LCD_HEIGHT			; 76800
TILEMAP_WIDTH					equ LCD_WIDTH/TILE_WIDTH			; 20
TILEMAP_HEIGHT					equ LCD_HEIGHT/TILE_HEIGHT			; 15
TILEMAP_AREA					equ TILEMAP_WIDTH*TILEMAP_HEIGHT	; 300

TICKS_ADDR   equ $F30024   ; 3-byte OS tick counter (increments at 60 Hz)




Facing.Up						equ %0001
Facing.Down						equ %0010
Facing.Left						equ %0100
Facing.Right					equ %1000

Type.Head						equ $0
Type.Body						equ $1
Type.Tail						equ $2
;
; Structs
;

; Snake Segment

SnakeSegment_Size				equ 4		; 1+1+1+1=4
; Attributes
SnakeSegment.Facing				equ 0		; 1 byte
SnakeSegment.Pos				equ 1
SnakeSegment.Pos.X				equ 1		; 1 byte
SnakeSegment.Pos.Y				equ 2		; 1 byte
SnakeSegment.Type				equ 3		; 1 byte

BlackTile						equ $000000
Apple							equ $000200
RightToTop						equ $000400
LeftToTop						equ $000600
BottomToRight					equ $000800
BottomToLeft					equ $000A00
BodyVertical					equ $000C00
BodyHorizontal					equ $000E00
HeadUp							equ $001000
HeadDown						equ $001200
HeadLeft						equ $001400
HeadRight						equ $001600
TailUp							equ $001800
TailDown						equ $001A00
TailLeft						equ $001C00
TailRight						equ $001E00



; Tells the assembler to assume ADL mode is on (basically 24-bit mode), which is the default
.assume ADL=1
; Tells the assembler this program will be located at userMem-2, so any memory addresses should be relative to that
; -2 because the program is placed at userMem, but there are 2 bytes that get removed at runtime (or smth like that, idk look at the tutorial)
.org userMem-2
	; Equivalent to Asm84CEPrgm in TI-BASIC
	.db tExtTok,tAsm84CeCmp
Start:
	;
	; Program code
	;

	; Reset the screen
	call _homeup
	call _ClrScrnFull
	
	call StartTimer

	call GetAppVar
	call ResetScreen
	call DrawSnake
	
	
;--------------------
; **Main Game Loop**
;--------------------
Main:
	; Get key press
	call _GetCSC
	or a							; Check if a key was actually pressed
	call nz, HandleKeyPress


	ld a, (ExitPrgm)
	or a
	jr nz, Exit


	; Timer Stuff
	call CheckTimer
	jr nc, Main						; If less than 0.5 seconds elapsed, don't do main loop

	; Snake Stuff
	call MoveSnake
	call DrawSnake


	jr Main

ErrorAppVarNotFound:
	ld hl, ErrorAppVarNotFoundStr
	jr Error
ErrorAppVarArchived:
	ld hl, ErrorAppVarArchivedStr
	jr Error
ErrorInvalidDirection:
	ld hl, ErrorInvalidDirectionStr
	jr Error
YouDied:
	ld hl, YouDiedStr
	jr Error
Error:
	call _PutS
	call _GetKey
	ld a, 1
	ld (ExitPrgm), a
	call DrawSnake					; Render the last frame
	ret

;----------------------
; **Exit the program**
;----------------------
Exit:
	; Disable the timer
	ld hl, 0								; Disable all timers (because its easier than disabling just timer 1)
	ld (TIMER_CTRL_REG), hl	

	; Hand control back over to the OS
	call _JForceCmdNoChar

	; Exits the program (Usually? idk)
	ret

;---------------------------------------------
; **Setup up a timer that waits 0.5 seconds**
;---------------------------------------------
StartTimer:
	ld hl, 0								; Disable all timers (because its easier than disabling just timer 1)
	ld (TIMER_CTRL_REG), hl		

	ld hl, 00471Ch							; 18204(0000471Ch) ticks / 36.4 KHz(I have no idea where this number comes from, it just works, ok?) equals 0.5 seconds (little-endian)
	ld (TIMER1_COUNTER), hl
	ld (TIMER1_RESET_VAL), hl
	ld a, 00h
	ld (TIMER1_COUNTER+3), a
	ld (TIMER1_RESET_VAL+3), a

	ld hl, TIMER1_ON|TIMER1_CPU_CLK|TIMER1_COUNT_DOWN	; Settings for timer
	ld (TIMER_CTRL_REG), hl
	ret

;--------------------------------------------------
; **Checks if the timer has hit 0**
; Inputs: None
; Outputs:
;	- CF - Set if timer has hit 0, Reset otherwise
;--------------------------------------------------
CheckTimer:
	ld a, (TIMER1_COUNTER+1)
	ld b, a
	ld a, (PreviousTime)
	cp b

	ld a, b									; Save current time
	ld (PreviousTime), a

	ret


;--------------------------------------
; **Gets AppVar stored in AppVarName**
;--------------------------------------
GetAppVar:
	ld hl, AppVarName
	call _Mov9ToOP1

	call _ChkFindSym
	jp c, ErrorAppVarNotFound

	; Check if AppVar is in RAM
	call _ChkInRam

	jp nz, ErrorAppVarArchived

	; Pointer to AppVar Data Section stored in de
	ld (AppVarPointer), de
	ret

;----------------------------------------------------------------
; **Gets the last keypress and does the corrisponding function**
; Params:
;	- A: keycode
;----------------------------------------------------------------
HandleKeyPress:
	ld b, 1
	ld c, 1

	cp a, skClear
	jr z, HandleKeyPress.Clear
	cp a, skUp
	jr z, HandleKeyPress.Up
	cp a, skDown
	jr z, HandleKeyPress.Down
	cp a, skLeft
	jr z, HandleKeyPress.Left
	cp a, skRight
	jr z, HandleKeyPress.Right
	ret

HandleKeyPress.Up:
	ld c, Facing.Up
	ld b, Facing.Down
	jr HandleKeyPress.Direction.Next
HandleKeyPress.Down:
	ld c, Facing.Down
	ld b, Facing.Up
	jr HandleKeyPress.Direction.Next
HandleKeyPress.Left:
	ld c, Facing.Left
	ld b, Facing.Right
	jr HandleKeyPress.Direction.Next
HandleKeyPress.Right:
	ld c, Facing.Right
	ld b, Facing.Left
	jr HandleKeyPress.Direction.Next

HandleKeyPress.Direction.Next:
	ld a, (SnakeFacingPrevious)
	cp b
	jr z, HandleKeyPress.Direction.Done

	ld a, c
	ld (SnakeFacing), a
HandleKeyPress.Direction.Done:
	ret

HandleKeyPress.Clear:
	ld a, b
	ld (ExitPrgm), a
	ret


;----------------------------------------
; **Draws that Apple to the LCD_BUFFER**
;----------------------------------------
DrawApple:
	ld hl, (AppVarPointer)
	ld de, Apple
	add hl, de
	ld a, (ApplePos)
	ld ixl, a
	ld a, (ApplePos+1)
	call SetTile
	ret

;---------------------------------------
; **Draws the Snake to the LCD_BUFFER**
;---------------------------------------
DrawSnake:
	ld iy, 0
	ld ix, Snake
	ld bc, (SnakeLength)
	inc bc
DrawSegment:
	dec bc
	push bc											; Save bc

	ld iy, (ix)
	push ix											; Save ix
	ld a, (iy+SnakeSegment.Type)
	ld b, (iy+SnakeSegment.Facing)



	ld hl, (AppVarPointer)
	ld de, 0

	cp a, Type.Head
	jr z, DrawSegment.Head
	cp a, Type.Body
	jr z, DrawSegment.Body

; Otherwise, Its tail
	;cp a, Type.Tail
	;jr z, DrawSegment.Tail

;DrawSegment.Tail:
	ld de, TailUp-HeadUp
	add hl, de
DrawSegment.Head:
	ld de, HeadUp
	add hl, de

	ld a, b
; Decide the direction
	; Get the size of 1 tile in the AppVar
	ld bc, TILE_WIDTH*TILE_HEIGHT*BYTES_PER_PIXEL

	cp a, Facing.Up
	jr z, DrawSegment.Head_Tail.Up
	cp a, Facing.Down
	jr z, DrawSegment.Head_Tail.Down
	cp a, Facing.Left
	jr z, DrawSegment.Head_Tail.Left

; Otherwse, its right		; If Right, it needs to add 3
	add hl, bc
DrawSegment.Head_Tail.Left:	; If Left, it needs to add 2
	add hl, bc
DrawSegment.Head_Tail.Down:	; If down, it needs to add 1
	add hl, bc
DrawSegment.Head_Tail.Up:	; If up, its already there
	jr DrawSegment.Done

DrawSegment.Body:
	pop ix
	push ix											; Get ix and immediately save it again

	; Get previous segment
	push iy
	ld iy, (ix-3)
	ld a, (iy+SnakeSegment.Facing)
	pop iy
	; a = Previous segment direction
	; b = Current segment direction
	cp a, b
	push af											; Save the flags

	; Move the previous segment direction into the high-order 4-bits of a
	sla a
	sla a
	sla a
	sla a
	or b

	ld c, a
	pop af											; Restore the flags
	ld a, c

	; Do this so that a is still shifted and or-ed
	jr z, DrawSegment.Equal

	tst a, Facing.Up|(Facing.Down<<4)
	jr nz, DrawSegment.Body.Up
	tst a, Facing.Down|(Facing.Up<<4)
	jr nz, DrawSegment.Body.Down

DrawSegment.Equal:
	ld de, BodyVertical
	jr DrawSegment.Body.Next

DrawSegment.Body.Up:
	ld de, RightToTop
	jr DrawSegment.Body.Next

DrawSegment.Body.Down:
	ld de, BottomToRight

DrawSegment.Body.Next:
	add hl, de

	tst a, Facing.Left|(Facing.Right<<4)
	jr z, DrawSegment.Done

	ld de, TILE_WIDTH*TILE_HEIGHT*BYTES_PER_PIXEL
	add hl, de
DrawSegment.Done:
	ld a, (iy+SnakeSegment.Pos.X)
	ld ixl, a
	ld a, (iy+SnakeSegment.Pos.Y)
	call SetTile
	
	pop ix											; Restore ix
	; Increment ix to the next pointer for the cycle after this one
	ld bc, 3
	add ix, bc
	pop bc											; Restore bc
	; If bc == 0, return
	ld a, b
	or a
	jp nz, DrawSegment
	ld a, c
	or a
	jp nz, DrawSegment
	ret




;------------------------------------
; **Resets the screen to all black**
;------------------------------------
ResetScreen:
	ld hl, LCD_BUFFER
	ld bc, LCD_AREA*BYTES_PER_PIXEL
RestScreen.clearLoop:
	ld (hl), 0
	inc hl
	dec bc
	; Check of bc is zero
	ld (Data), bc										; bc is 24-bit so I have to load it into memory, then load each bit seperately and or them all together
	ld a, (Data+2)
	or b
	or c
	jr nz, RestScreen.clearLoop
	call BlitScreen
	ret

;
; Blits the frame buffer to the screen
;
BlitScreen:
	call $4544    ; _BlitLCD BCALL address for OS 5.8.x
	ret



; TODO: Finish this function
;----------------------------------
;**Moves the snake 1 Tile forward**
;----------------------------------
MoveSnake:
	; Move the current direction into the previous direction
	ld a, (SnakeFacing)
	ld (SnakeFacingPrevious), a

	; Set old tail to a black tile
	ld hl, (AppVarPointer)
	ld bc, BlackTile
	add hl, bc
	ld iy, (Snake)								; typeof(iy) = SnakeSegment*
	ld b, (iy+SnakeSegment.Pos.X)				; typeof(iy) = SnakeSegment.X
	ld ixl, b
	ld a, (iy+SnakeSegment.Pos.Y)				; typeof(iy) = SnakeSegment.Y
	call SetTile


	; Get head pointer
	ld bc, (SnakeLength)
	dec bc										; Otherwise off-by-one error, reads 3 bytes farther than its supposed to
	ld a, 3
	call mul
	ld (Data), hl								; Save mul result
	ld bc, Snake
	add hl, bc									; hl = head SnakeSegment**
	ld (Data+3), hl								; Save head SnakeSegment**

	; Set old head direction
	ld ix, (hl)									; ix = head SnakeSegment*
	ld a, (SnakeFacing)
	ld (ix+SnakeSegment.Facing), a				; Set the old head to be facing the right direction (do this before the copy)
	
	; Create new head
	ld de, (hl)									; Copy head SnakeSegment** into de
	ld hl, (hl)									; Copy head SnakeSegment** into hl
	ld bc, SnakeSegment_Size
	add hl, bc									; Add offset
	ex de, hl									; Can't do "add de, bc"
	ld (Data+6), de								; Save the new pointer
	ldir										; Move current head to next segment

	; Set old head to be a body tile
	ld (ix+SnakeSegment.Type), Type.Body		; Set the old head to be a body


	; Move the new head in the correct direction
	ld ix, (Data+6)								; Load the new pointer
	ld de, 0
	ld a, (ix+SnakeSegment.Facing)
	cp Facing.Up
	jr z, MoveSnake.Up
	cp Facing.Down
	jr z, MoveSnake.Down
	cp Facing.Left
	jr z, MoveSnake.Left
	cp Facing.Right
	jr z, MoveSnake.Right
	jp ErrorInvalidDirection
MoveSnake.Up:
	ld a, (ix+SnakeSegment.Pos.Y)
	ld c, 00h
	cp c
	jp z, YouDied
	ld b, 0FFh
	jr MoveSnake.Vertical
MoveSnake.Down:
	ld a, (ix+SnakeSegment.Pos.Y)
	ld c, TILEMAP_HEIGHT-1							; -1 because coords are 0-based
	cp c
	jp z, YouDied
	ld b, 1h
MoveSnake.Vertical:
	add a, b
	ld (ix+SnakeSegment.Pos.Y), a
	jr MoveSnake.DoneMoveHead

MoveSnake.Left:
	ld a, (ix+SnakeSegment.Pos.X)
	ld c, 00h
	cp c
	jp z, YouDied
	ld b, 0FFh
	jr MoveSnake.Horizontal
MoveSnake.Right:
	ld a, (ix+SnakeSegment.Pos.X)
	ld c, TILEMAP_WIDTH-1							; -1 because coords are 0-based
	cp c
	jp z, YouDied
	ld b, 1h
MoveSnake.Horizontal:
	add a, b
	ld (ix+SnakeSegment.Pos.X), a

MoveSnake.DoneMoveHead:

	; Check if there's an apple
	ld iy, (Data+6)								; typeof(iy) = SnakeSegment*
	ld d, (iy+SnakeSegment.Pos.X)
	ld e, (iy+SnakeSegment.Pos.Y)

	ld hl, (ApplePos)
	scf
	ccf
	sbc hl, de
	jr z, MoveSnake.Apple

; No Apple
	; Shift all of the pointers up by 1
	ld hl, Snake
	inc hl
	inc hl
	inc hl
	ld de, Snake
	ld bc, (Data)								; Get mul result
	ldir
	
	; Set new head pointer
	ld hl, (Data+6)								; Load the new pointer
	ld ix, (Data+3)								; Copy head SnakeSegment** into ix
	ld (ix), hl									; Set the new pointer

	jr MoveSnake.AppleDone
MoveSnake.Apple:
	; Set new head pointer
	ld hl, (Data+6)								; Load the new pointer
	ld ix, (Data+3)								; Copy head SnakeSegment** into ix
	ld (ix+3), hl								; Set the new pointer

	; Increase length
	ld hl, (SnakeLength)
	inc hl
	ld (SnakeLength), hl
MoveSnake.AppleDone:

	; Set up to check overlap
	ld iy, (Data+6)								; typeof(iy) = SnakeSegment*
	ld de, 0									; de is 24-bit, so make sure the high-order byte is 0
	ld d, (iy+SnakeSegment.Pos.X)
	ld e, (iy+SnakeSegment.Pos.Y)
	ld ix, (Snake)

	; Don't count the head
	dec iy
	dec iy
	dec iy
	dec iy
	ld (Data+6), iy
MoveSnake.CheckOverlapping:
	ld hl, 0

	ld h, (ix+SnakeSegment.Pos.X)
	ld l, (ix+SnakeSegment.Pos.Y)
 

	scf											; Reset carry
	ccf
	sbc hl, de
	jp z, YouDied								; Check if head overlapping with segment
	inc ix										; Move to next segment pointer
	inc ix
	inc ix
	inc ix

	push ix										; ld bc, ix
	pop bc
	ld hl, (Data+6)								; Load the pointer to the segment before the head
	scf											; Reset carry
	ccf
	sbc hl, bc									; cp hl, bc
	jr nz, MoveSnake.CheckOverlapping			; If current segment is not the last body segment, loop again


	; Set the new tail to be a tail
	ld ix, (Snake)
	ld (ix+SnakeSegment.Type), Type.Tail


	ret


; TODO: Implement this function
;---------------------------------------------------------------------------------------
; **Resets the Snake Segments so that they are a the beginning of the reserved memory**
;---------------------------------------------------------------------------------------
ResetSegments:
ret

;---------------------------------------------------
; **Moves a given tile into the given render buffer**
; Destroys: de, bc
; Params:
; - HL: Pointer to Tile
; - IXL: x pos to place the top left of the tile at
; - A: y pos to place the top left of the tile at
;---------------------------------------------------
SetTile:
	ld de, LCD_BUFFER

	push hl												; Save hl
	push ix

	ld bc, LCD_WIDTH*TILE_HEIGHT*BYTES_PER_PIXEL
	push de
	call mul											; yPos * TILE_HEIGHT * LCD_WIDTH
	pop de

	add hl, de											; Add y offset to *RENDER_BUFFER
	ex de, hl
	
	pop ix
	ld a, ixl
	ld bc, TILE_WIDTH*BYTES_PER_PIXEL
	push de
	call mul											; xPos * TILE_WIDTH
	pop de

	add hl, de											; Add x offset to *RENDER_BUFFER
	ex de, hl

	pop hl												; Restore hl

	ld a, TILE_HEIGHT

	ld bc, TILE_WIDTH*BYTES_PER_PIXEL
	push bc
SetTile.loop:
	pop bc
	push bc
	; Copy memory
	ldir												; Copy 1 row of data from tile buffer to RENDER_BUFFER

	; Move down 1 line to the begnning of the Tile
	push hl												; Start de += (LCD_WIDTH_SUB_TILE_WIDTH - 1)
	ld hl, (LCD_WIDTH-TILE_WIDTH)*BYTES_PER_PIXEL		; -1 because the buffers are 0-based
	add hl, de
	ex de, hl
	pop hl												; End de += (LCD_WIDTH_SUB_TILE_WIDTH - 1)

	dec a
	or a
	jr nz, SetTile.loop
	pop bc
	ret


;--------------------------------------------------------------
; **HL = A * BC**
; Destroys: de, ix
; Params:
;	- A: first number - 8-bit
;	- BC: second number - 16-bit
; Output:
;	- HL: result - 24-bit
;--------------------------------------------------------------
mul:
	ld h, b
	ld l, a
	call _HtimesL

	ld (Data), hl
	ld ix, Data
	
	; de <<= 8
	sla (ix)
	rl (ix+1)
	rl (ix+2)

	sla (ix)
	rl (ix+1)
	rl (ix+2)
	
	sla (ix)
	rl (ix+1)
	rl (ix+2)
	
	sla (ix)
	rl (ix+1)
	rl (ix+2)
	
	sla (ix)
	rl (ix+1)
	rl (ix+2)
	
	sla (ix)
	rl (ix+1)
	rl (ix+2)
	
	sla (ix)
	rl (ix+1)
	rl (ix+2)
	
	sla (ix)
	rl (ix+1)
	rl (ix+2)
	ld de, (ix)
	push de

	ld h, c
	ld l, a
	call _HtimesL

	pop de
	add hl, de
	ret








;--------------
; Vars
;--------------

ExitPrgm:
	.db 0



; Error Messages
ErrorAppVarArchivedStr:
	.db "ERROR, AppVar is archived, please move it into RAM", 0
ErrorAppVarNotFoundStr:
	.db "ERROR, AppVar not found", 0
ErrorInvalidDirectionStr:
	.db "ERROR, The current movement direction has been set to an invalid value", 0
YouDiedStr:
	.db "You Died", 0



; AppVar

AppVarName:
	; "VARNAME", 0 (0-padded to 8 bytes), 15h
	.db AppVarObj, "SNKSKN", 0, 0, 0, 0
AppVarPointer:
	.fill 3, 0



; Timer

PreviousTime:
	.db 0FFh


ApplePos:
	.db 0	; X
	.db 0	; Y
	.db 0	; Padding
; Snake
SnakeFacing:
	.dl Facing.Right
SnakeFacingPrevious:
	.dl Facing.Right
SnakeLength:
	; Little Endian
	.db 9, 0, 0
Snake:
	; db - 1 byte, dw - 2 bytes, dl - 3 bytes
	.dl Segments+(0*SnakeSegment_Size)
	.dl Segments+(1*SnakeSegment_Size)
	.dl Segments+(2*SnakeSegment_Size)
	.dl Segments+(3*SnakeSegment_Size)
	.dl Segments+(4*SnakeSegment_Size)
	.dl Segments+(5*SnakeSegment_Size)
	.dl Segments+(6*SnakeSegment_Size)
	.dl Segments+(7*SnakeSegment_Size)
	.dl Segments+(8*SnakeSegment_Size)

	.fill 3*(TILEMAP_AREA - 9), 0							; *SnakeSegment[LCD_AREA]
Segments:
	; Facing, Pos.X, Pos.Y, Type
	.db Facing.Right, 0, TILEMAP_HEIGHT-1, Type.Tail
	.db Facing.Right, 1, TILEMAP_HEIGHT-1, Type.Body
	.db Facing.Right, 2, TILEMAP_HEIGHT-1, Type.Body
	.db Facing.Right, 3, TILEMAP_HEIGHT-1, Type.Body
	.db Facing.Right, 4, TILEMAP_HEIGHT-1, Type.Body
	.db Facing.Right, 5, TILEMAP_HEIGHT-1, Type.Body
	.db Facing.Right, 6, TILEMAP_HEIGHT-1, Type.Body
	.db Facing.Right, 7, TILEMAP_HEIGHT-1, Type.Body

	; Snake Render Check
	; .db Facing.Up, 8, TILEMAP_HEIGHT-1, Type.Body
	; .db Facing.Up, 8, TILEMAP_HEIGHT-2, Type.Body
	; .db Facing.Up, 8, TILEMAP_HEIGHT-3, Type.Body
	; .db Facing.Left, 8, TILEMAP_HEIGHT-4, Type.Body
	
	; .db Facing.Left, 7, TILEMAP_HEIGHT-4, Type.Body
	; .db Facing.Left, 6, TILEMAP_HEIGHT-4, Type.Body
	; .db Facing.Down, 5, TILEMAP_HEIGHT-4, Type.Body

	; .db Facing.Down, 5, TILEMAP_HEIGHT-3, Type.Body
	; .db Facing.Right, 5, TILEMAP_HEIGHT-2, Type.Body

	; .db Facing.Up, 6, TILEMAP_HEIGHT-2, Type.Body
	; .db Facing.Right, 6, TILEMAP_HEIGHT-3, Type.Body
	; .db Facing.Down, 7, TILEMAP_HEIGHT-3, Type.Body


	.db Facing.Right, 8, TILEMAP_HEIGHT-1, Type.Head
	.fill SnakeSegment_Size*(TILEMAP_AREA - 9), 0			; SnakeSegment[LCD_AREA]


; Extra memory for short-term storage
Data:
	.fill 64, 0